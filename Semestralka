// Online C++ compiler to run C++ program online
#include <iostream>
#include <map>
#include <vector>
#include <algorithm>
using namespace std;

class Matrix
{
    public:
    
    map <array<int, 2>, double> newmap;
    
    void set()
    {
    newmap[{1,1}]=5;
    newmap[{1,2}]=-3;
    newmap[{2,1}]=-3;
    newmap[{2,2}]=5;

    }

    void printed()
    {
    map <array<int, 2>, double>:: iterator itern=newmap.begin();
    
    for(int j=0; itern!=newmap.end(); itern++,j++)
    {
    cout<<itern->first[0]<<" "<<itern->first[1]<<" "<<itern->second<<endl;
    }    
    
    }
   
    
};

class Vektor
{
    
    public:
    map <int, double> newmap;

    void set()
    {
    newmap[1]=-1;
    newmap[2]=7;
    }
    void setN()
    {
    newmap[1]=0;
    newmap[2]=0;
    }
    void setP()
    {
    newmap[1]=0;
    newmap[2]=-1;
    }

    void printed()
    {
    map <int, double>:: iterator itern=newmap.begin();
    
    for(int j=0; itern!=newmap.end(); itern++,j++)
    {
    cout<<itern->first<<" "<<itern->second<<endl;
    }    
    
    }
   
        
};
    
Vektor nasobeni(Matrix a, Vektor b)
{  
        Vektor c;
        
        map <array<int, 2>, double>:: iterator it=a.newmap.begin();
    
        double pom=0;
    
        for(int j=0; it!=a.newmap.end(); it++,j++)
        {
        pom=(it->second)*b.newmap[it->first[1]];
        //cout<<(it->second)<<"*"<<b.newmap[it->first[1]]<<"="<<pom<<endl;
        c.newmap[it->first[0]]+=pom;
        }    

        return c;
}
    
double nasobeni(Vektor a, Vektor b)
{
        double c=0;
        map <int, double>:: iterator it=a.newmap.begin();
        
        for(int j=0; it!=a.newmap.end(); it++,j++)
        {
        c=c+(it->second)*b.newmap[it->first];
        }
        return c;
        
}

Vektor nasobeni(double a, Vektor b)
{
        Vektor c;
        
        map <int, double>:: iterator it=b.newmap.begin();
    
        double pom=0;
    
        for(int j=0; it!=b.newmap.end(); it++,j++)
        {
        pom=a*(it->second);
        c.newmap[it->first]=pom;
        }    
        
    
        return c;
        
}


Vektor rozdil(Vektor a, Vektor b)
{
        Vektor c;
        
        
        map <int, double>:: iterator it1=a.newmap.begin();
        map <int, double>:: iterator it2=b.newmap.begin();
        
        vector <double> pom; //pomocny vektor prvku ktere se zucastnili operace
        double p; //pomocny prvek pro rozdil
  
        for(int j=0; it1!=a.newmap.end(); it1++,j++)
        {
            
        p=(it1->second)-b.newmap[it1->first];
        c.newmap[it1->first]=p;
        
        pom.push_back(it1->first);
        
        }    
        
        double key=0;    
        for(int j=0; it2!=b.newmap.end(); it2++,j++)
        {
    
        key=it2->first;
            if (find(pom.begin(), pom.end(), key) != pom.end()) {}
            else {c.newmap[it2->first]=-it2->second;}    
    
        }    

        
        return c;
}
Vektor soucet(Vektor a, Vektor b)
{
        Vektor c;
        
        
        map <int, double>:: iterator it1=a.newmap.begin();
        map <int, double>:: iterator it2=b.newmap.begin();
        
        vector <double> pom; //pomocny vektor prvku ktere se zucastnili operace
        double p; //pomocny prvek pro rozdil
  
        for(int j=0; it1!=a.newmap.end(); it1++,j++)
        {
            
        p=(it1->second)+b.newmap[it1->first];
        c.newmap[it1->first]=p;
        
        pom.push_back(it1->first);
        
        }    
        
        double key=0;    
        for(int j=0; it2!=b.newmap.end(); it2++,j++)
        {
    
        key=it2->first;
            if (find(pom.begin(), pom.end(), key) != pom.end()) {}
            else {c.newmap[it2->first]=it2->second;}    
    
        }    

        
        return c;
}

int main() {
    
    Matrix A;
    Vektor r,x0,p,z,x,b,null_v;
    double alfa,beta,lrr,rr;
    
    int n=2;
    A.set();
    
    x0.setP();
    //x0.printed();
    
    b.set();
    //b.printed();
    
    null_v.setN();
    //null_v.printed();
    
  
    r=rozdil(b,nasobeni(A,x0));
    cout<<"r---------------"<<endl;
    r.printed();
    
    lrr=nasobeni(r,r);
    cout<<lrr<<endl;
    
    p=r;
    p.printed();
    
    x=x0;
    x.printed();
    cout<<"CYKLUS----------------------------CYKLUS"<<endl;
    
    for(int k=1; k<=n; k++)
    {
        z=nasobeni(A,p);
      //  A.printed();
      //  p.printed();
      //  z.printed();
        
        alfa=lrr/nasobeni(p,z);
      //  cout<<"lrr="<<lrr<<endl;
      //  cout<<"p*z="<<nasobeni(p,z)<<endl;
      //  cout<<"alfa="<<alfa<<endl;
        
        x=soucet(x,nasobeni(alfa,p)); 
      //  cout<<"x        ="<<endl;
        //x.printed();
       // cout<<"x        ="<<endl;
        
        r=rozdil(r,nasobeni(alfa,z)); 
        //cout<<"r        ="<<endl;
       // r.printed();
       // cout<<"r        ="<<endl;
        
        
        
        //if (r==null_v) {break;}
        rr=nasobeni(r,r);
        //cout<<"rr        ="<<rr<<endl;
        
        beta=rr/lrr;
        //cout<<"beta="<<beta<<endl;
        
        lrr=rr;
        cout<<"lrr        ="<<lrr<<endl;
        
        p=soucet(r,nasobeni(beta,p));
        //x.printed();
    }

    x.printed();
    
    //nasobeni(A,p).printed();
    
    return 0;
}
